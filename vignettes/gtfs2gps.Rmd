---
title: 'gtfs2gps: Converting GTFS data to GPS format'
author: "Rafael H. M. Pereira, Pedro R. Andrade"
date: "`r format('17 September 2019')`"
urlcolor: blue
output:
  pdf_document:
    fig_caption: yes
    latex_engine: pdflatex
  html_document:
    df_print: paged
abstract: This package has a set of functions to convert GTFS data to GPS format using data.table. It also has some functions to subset such data in time and space.
vignette: |
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{colrow: Handling SimU, CR, and LU datas}
  %\VignetteEncoding{UTF-8}
---

# Introduction 

This package allows users to handle and converting GTFS data using data.table. Before using the package, just install it from GitHub.

```{r, eval = FALSE}
devtools::install_github("ipeaGIT/gtfs2gps")
```

# Loading data

After loading the package, GTFS data can be read into R by using `read_gtfs()`.
This function gets a zipped GTFS file and returns a list of `data.table` objects. The returning list contains the data of each GTFS file indexed according to their names.

```{r}
library("gtfs2gps")
sp <- read_gtfs(system.file("extdata/saopaulo.zip", package="gtfs2gps"))
names(sp)
```

Note that not all GTFS files are loaded into R. This function loads only the necessary data to spatially and temporally handle trips and stops, which are:
agency, calendar, routes, shapes, 
stop_times, stops, trips, and frequencies (this last one is optional).
If a given GTFS zipped file does not contain all the required files then `read_gtfs()` will stop with an error.

# Simplifying Data

As GTFS data are usually very big, any exploratory analysis usually involves subestting  it in order to speedup the process. There are some functions to filter a GTFS data:

\begin{description}
\item[filter\_by\_shape\_id()]: Filter shapes using given shape ids.
\item[filter\_valid\_stop\_times()]: Return only stop times that have geospatial locations.
\item[filter\_week\_days()]: Remove weekend trips.
\end{description}

These functions also subset all the other GTFS files in order to remove all the unnecessary rows, keeping the data consistent. The returning values of the three functions is a `data.table`. For example, in the code below we filter only shape ids between 53000 and 55000.

```{r}
library(magrittr)

object.size(sp) %>% format(units="Kb")

sp_small <- gtfs2gps::filter_by_shape_id(sp, 53000:53020)

object.size(sp_small) %>% format(units="Kb")
```

Note that `shape\_id` might be a string or a number, depending on the available values.

```{r}
sp_sf <- gtfs_shapes_as_sf(sp)
sp_small_sf <- gtfs_shapes_as_sf(sp_small)

plot(sf::st_geometry(sp_sf))
plot(sf::st_geometry(sp_small_sf), col = "blue", add = TRUE)
box()
```

After simplifying the data, it is possible to save it as a GTFS file, as shown below.

```{r}
write_gtfs(sp_small, "sp_small.zip")
```

# Converting to GPS format

To convert GTFS to GPS format, use `gtfs2gps()`. [...]

```{r}
  poa_gps <- gtfs2gps_dt_parallel("sp_small.zip")
  poa_gps
```

Finally, we can plot the points as shown below.

```{r}
  poa_gps_sf <- sf::st_as_sf(x = poa_gps,
           coords = c("shape_pt_lon", "shape_pt_lat"),
           crs = 4326)
  
  plot(sf::st_geometry(poa_gps_sf))
  plot(sf::st_geometry(sp_small_sf), col = "blue", add = TRUE)
  box()
```

As the points are created using a distance of $15m$, it is necessary to zoom in to visually separate them. The following figure shows the points in a bounding box from the first 60 points.

```{r}
  poa_gps_small <- poa_gps[1:60, ]

  poa_gps_small_sf <- sf::st_as_sf(x = poa_gps_small,
           coords = c("shape_pt_lon", "shape_pt_lat"),
           crs = 4326)
  
  plot(sf::st_geometry(poa_gps_small_sf), pch = 20)
  plot(sf::st_geometry(sp_small_sf), col = "blue", add = TRUE)
  plot(sf::st_geometry(poa_gps_sf), add = TRUE, pch = 20)
  box()
```

# Final remarks

If you have any suggestions or want to report an error, please visit the GitHub page of the package [here](https://github.com/ipeaGIT/gtfs2gps).
