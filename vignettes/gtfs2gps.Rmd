---
title: 'gtfs2gps: Converting GTFS data to GPS format'
author: "Rafael H. M. Pereira, Pedro R. Andrade, Joao Bazzo"
date: "`r format('25 November 2019')`"
output:
  pdf_document:
    fig_caption: yes
    latex_engine: pdflatex
  word_document: default
  html_document:
    df_print: paged
abstract: Package `gtfs2gps` has a set of functions to convert GTFS data to GPS format
  using `data.table`. It also has some functions to subset GTFS data in time and space
  and to convert both representations to simple feature format.
urlcolor: blue
vignette: |
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{colrow: Handling SimU, CR, and LU datas}
---

# Introduction 

Package `gtfs2gps` allows users to handle and converting GTFS data using `data.table` format. Before using the package, just install it from GitHub.

```{r, eval = FALSE}
devtools::install_github("ipeaGIT/gtfs2gps")
```

# Loading data

After loading the package, GTFS data can be read into R by using `read_gtfs()`.
This function gets a zipped GTFS file and returns a list of `data.table` objects. The returning list contains the data of each GTFS file indexed according to their file names without extension.

```{r}
library("gtfs2gps")
sp <- read_gtfs(system.file("extdata/saopaulo.zip", package="gtfs2gps"))
names(sp)
sp$trips
```

Note that not all GTFS files are loaded into R. This function loads only the necessary data to spatially and temporally handle trips and stops, which are:
agency.txt, calendar.txt, routes.txt, shapes.txt, 
stop_times.txt, stops.txt, trips.txt, and frequencies.txt (this last one is optional).
If a given GTFS zipped file does not contain all the required files then `read_gtfs()` will stop with an error.

# Simplifying Data

As GTFS data are usually very big, any exploratory analysis has to firstly subset it in order to speedup the process. There are some functions to filter a GTFS data:

\begin{description}
\item[filter\_by\_shape\_id():] Filter shapes using given shape ids.
\item[filter\_valid\_stop\_times():] Return only stop times that have geospatial locations.
\item[filter\_week\_days():] Remove weekend trips.
\item[filter\_single\_trip():] Return only one trip per shape\_id.
\end{description}

These functions subset all the relevant GTFS files in order to remove all the unnecessary rows, keeping the data consistent. The returning values of the four functions is a list of `data.table` objects, in the same way of the input data. For example, in the code below we filter only shape ids between 53000 and 53020.

```{r}
library(magrittr)
object.size(sp) %>% format(units = "Kb")
sp_small <- gtfs2gps::filter_by_shape_id(sp, 53000:53020)
object.size(sp_small) %>% format(units = "Kb")
```

We can then convert both data to simple feature format and plot them.

```{r}
sp_sf <- gtfs2gps::gtfs_shapes_as_sf(sp)
sp_small_sf <- gtfs2gps::gtfs_shapes_as_sf(sp_small)
plot(sf::st_geometry(sp_sf))
plot(sf::st_geometry(sp_small_sf), col = "blue", add = TRUE)
box()
```

After simplifying the data, it is also possible to save it as a new GTFS file using `write_gtfs()`, as shown below.

```{r}
write_gtfs(sp_small, "sp_small.zip")
```

# Converting to GPS format

To convert GTFS to GPS format, use `gtfs2gps()`. This
function takes a GTFS zipped file as argument and returns a
`data.table` where each row works as a GPS sample for a given
trip in the GTFS file. See the example as follows.

```{r}
  sp_gps <- gtfs2gps("sp_small.zip", progress = FALSE)
  sp_gps
```

The public transportation stop_id's is usually distributed along the trip, with different values of speed between each other. Therefore, for a given trip, the function `gtfs2gps` considers different ranges of mean speed --- given by the ratio between cumulative distance $S$ and departure time $t$ for a consecutive pair of valid stop_ids ($i$), 
$$
Speed_i = \frac{S_{i+1}-S_i}{t_{i+1}-t_i}.
$$
Since the beginning of each trip usually starts before the first stop_id, the mean speed cannot be calculated as shown in the previous equation because information on $i$ period does not exist. In this case, the function consider the mean speed for the whole trip. It also happens after the last valid stop_id ($N$) of the trips, where info on $i+1$ also does not exist. 

$$
Speed_N = Speed_0 = \overline{Speed} = \frac{S_N-S_1}{t_N-t_1}
$$
![alt text](https://raw.githubusercontent.com/Joaobazzo/gtfs2gps/master/vignettes/speed.PNG "Logo Title Text 1")

Finally, we can plot the points as shown below.
As the points are created using a distance of $15m$, it is necessary to zoom in to visually separate them. The following figure shows the points in a bounding box from the first 60 points.

```{r}
  sp_gps_sf <- gps_as_sf(sp_gps)
  sp_gps_small <- sp_gps[1:60, ]
  sp_gps_small_sf <- gps_as_sf(sp_gps_small)
  
  plot(sf::st_geometry(sp_gps_small_sf), pch = 20)
  plot(sf::st_geometry(sp_small_sf), col = "blue", add = TRUE)
  plot(sf::st_geometry(sp_gps_sf), add = TRUE, pch = 20)
  box()
```

Function `gtfs2gps()` also works with GTFS data that do not have frequency.txt. It automatically recognises the format and then it uses only stop_times.txt to create the GPS data.

```{r}
poa <- system.file("extdata/poa.zip", package="gtfs2gps")
poa_gps <- gtfs2gps(poa, progress = FALSE)
poa_gps_sf <- gps_as_sf(poa_gps)
poa_sf <- read_gtfs(poa) %>% gtfs_shapes_as_sf()
plot(sf::st_geometry(poa_gps_sf[1:200,]))
plot(sf::st_geometry(poa_sf), col = "blue", add = TRUE)
box()
```

# Final remarks

If you have any suggestions or want to report an error, please visit the GitHub page of the package [here](https://github.com/ipeaGIT/gtfs2gps).